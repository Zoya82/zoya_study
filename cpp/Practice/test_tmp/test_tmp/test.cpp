//#include <iostream>
//#include <vector>
//#include <algorithm>
//#include <string>
//#include <unordered_map>
//
//using namespace std;
//
//int ope(vector<int>& A,vector<int>& B) 
//{
//	unordered_map<int, int> count1, count2;
//
//	for (int a : A)
//	{
//		count1[a]++;
//	}
//	for (int b : B)
//	{
//		count2[b]++;
//	}
//
//	for(auto& )
//}
////int main()
////{
////	int n1,n2;
////	cin >> n1;
////	vector<int> A(n1);
////
////	for (int i = 0; i < n1; i++)
////	{
////		cin >> A[i];
////	}
////
////	cin >> n2;
////	vector<int> B(n2);
////
////	for (int i = 0; i < n2; i++)
////	{
////		cin >> B[i];
////	}
////
////	/*sort(A.begin(), A.end());
////	sort(B.begin(), B.end());
////
////	vector<string> operations;
////
////	int i = 0, j = 0;
////	while (i < n1 && j < n2)
////	{
////		if (A[i] == B[j])
////		{
////			i++;
////			j++;
////		}
////		else if (A[i] > B[j])
////		{
////			operations.push_back("delete " + to_string(j));
////			B.erase(B.begin() + j);
////		}
////		else
////		{
////			operations.push_back("insert " + to_string(i));
////			i++;
////		}
////	}
////
////	while (i < n1)
////	{
////		operations.push_back("insert " + to_string(A[i]));
////		i++;
////	}
////
////	while (j < n2)
////	{
////		operations.push_back("delete " + to_string(j));
////		B.erase(B.begin() + j);
////		n2--;
////	}
////
////	cout << operations.size() << endl;
////	for (const string& op : operations)
////	{
////		cout << op << endl;
////	}*/
////
////
////
////	return 0;
////}
